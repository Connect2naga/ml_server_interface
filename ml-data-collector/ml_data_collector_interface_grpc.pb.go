// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.6.1
// source: ml_data_collector_interface.proto

package ml_data_collector

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// IterationHandlerClient is the client API for IterationHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IterationHandlerClient interface {
	SetupIterationExperiment(ctx context.Context, in *Experiment, opts ...grpc.CallOption) (*Null, error)
	StartIterationExperiment(ctx context.Context, in *IterationReq, opts ...grpc.CallOption) (*Null, error)
	StatusIterationExperiment(ctx context.Context, in *Experiment, opts ...grpc.CallOption) (*IterationResp, error)
}

type iterationHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewIterationHandlerClient(cc grpc.ClientConnInterface) IterationHandlerClient {
	return &iterationHandlerClient{cc}
}

func (c *iterationHandlerClient) SetupIterationExperiment(ctx context.Context, in *Experiment, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := c.cc.Invoke(ctx, "/experiment.ml_data_collector.IterationHandler/SetupIterationExperiment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iterationHandlerClient) StartIterationExperiment(ctx context.Context, in *IterationReq, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := c.cc.Invoke(ctx, "/experiment.ml_data_collector.IterationHandler/StartIterationExperiment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iterationHandlerClient) StatusIterationExperiment(ctx context.Context, in *Experiment, opts ...grpc.CallOption) (*IterationResp, error) {
	out := new(IterationResp)
	err := c.cc.Invoke(ctx, "/experiment.ml_data_collector.IterationHandler/StatusIterationExperiment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IterationHandlerServer is the server API for IterationHandler service.
// All implementations must embed UnimplementedIterationHandlerServer
// for forward compatibility
type IterationHandlerServer interface {
	SetupIterationExperiment(context.Context, *Experiment) (*Null, error)
	StartIterationExperiment(context.Context, *IterationReq) (*Null, error)
	StatusIterationExperiment(context.Context, *Experiment) (*IterationResp, error)
	mustEmbedUnimplementedIterationHandlerServer()
}

// UnimplementedIterationHandlerServer must be embedded to have forward compatible implementations.
type UnimplementedIterationHandlerServer struct {
}

func (UnimplementedIterationHandlerServer) SetupIterationExperiment(context.Context, *Experiment) (*Null, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetupIterationExperiment not implemented")
}
func (UnimplementedIterationHandlerServer) StartIterationExperiment(context.Context, *IterationReq) (*Null, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartIterationExperiment not implemented")
}
func (UnimplementedIterationHandlerServer) StatusIterationExperiment(context.Context, *Experiment) (*IterationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusIterationExperiment not implemented")
}
func (UnimplementedIterationHandlerServer) mustEmbedUnimplementedIterationHandlerServer() {}

// UnsafeIterationHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IterationHandlerServer will
// result in compilation errors.
type UnsafeIterationHandlerServer interface {
	mustEmbedUnimplementedIterationHandlerServer()
}

func RegisterIterationHandlerServer(s grpc.ServiceRegistrar, srv IterationHandlerServer) {
	s.RegisterService(&IterationHandler_ServiceDesc, srv)
}

func _IterationHandler_SetupIterationExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Experiment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IterationHandlerServer).SetupIterationExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/experiment.ml_data_collector.IterationHandler/SetupIterationExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IterationHandlerServer).SetupIterationExperiment(ctx, req.(*Experiment))
	}
	return interceptor(ctx, in, info, handler)
}

func _IterationHandler_StartIterationExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IterationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IterationHandlerServer).StartIterationExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/experiment.ml_data_collector.IterationHandler/StartIterationExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IterationHandlerServer).StartIterationExperiment(ctx, req.(*IterationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _IterationHandler_StatusIterationExperiment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Experiment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IterationHandlerServer).StatusIterationExperiment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/experiment.ml_data_collector.IterationHandler/StatusIterationExperiment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IterationHandlerServer).StatusIterationExperiment(ctx, req.(*Experiment))
	}
	return interceptor(ctx, in, info, handler)
}

// IterationHandler_ServiceDesc is the grpc.ServiceDesc for IterationHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IterationHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "experiment.ml_data_collector.IterationHandler",
	HandlerType: (*IterationHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetupIterationExperiment",
			Handler:    _IterationHandler_SetupIterationExperiment_Handler,
		},
		{
			MethodName: "StartIterationExperiment",
			Handler:    _IterationHandler_StartIterationExperiment_Handler,
		},
		{
			MethodName: "StatusIterationExperiment",
			Handler:    _IterationHandler_StatusIterationExperiment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ml_data_collector_interface.proto",
}

// IterationCallBacksHandlerClient is the client API for IterationCallBacksHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IterationCallBacksHandlerClient interface {
	IterationsResults(ctx context.Context, in *IterationResp, opts ...grpc.CallOption) (*Null, error)
}

type iterationCallBacksHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewIterationCallBacksHandlerClient(cc grpc.ClientConnInterface) IterationCallBacksHandlerClient {
	return &iterationCallBacksHandlerClient{cc}
}

func (c *iterationCallBacksHandlerClient) IterationsResults(ctx context.Context, in *IterationResp, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := c.cc.Invoke(ctx, "/experiment.ml_data_collector.IterationCallBacksHandler/IterationsResults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IterationCallBacksHandlerServer is the server API for IterationCallBacksHandler service.
// All implementations must embed UnimplementedIterationCallBacksHandlerServer
// for forward compatibility
type IterationCallBacksHandlerServer interface {
	IterationsResults(context.Context, *IterationResp) (*Null, error)
	mustEmbedUnimplementedIterationCallBacksHandlerServer()
}

// UnimplementedIterationCallBacksHandlerServer must be embedded to have forward compatible implementations.
type UnimplementedIterationCallBacksHandlerServer struct {
}

func (UnimplementedIterationCallBacksHandlerServer) IterationsResults(context.Context, *IterationResp) (*Null, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IterationsResults not implemented")
}
func (UnimplementedIterationCallBacksHandlerServer) mustEmbedUnimplementedIterationCallBacksHandlerServer() {
}

// UnsafeIterationCallBacksHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IterationCallBacksHandlerServer will
// result in compilation errors.
type UnsafeIterationCallBacksHandlerServer interface {
	mustEmbedUnimplementedIterationCallBacksHandlerServer()
}

func RegisterIterationCallBacksHandlerServer(s grpc.ServiceRegistrar, srv IterationCallBacksHandlerServer) {
	s.RegisterService(&IterationCallBacksHandler_ServiceDesc, srv)
}

func _IterationCallBacksHandler_IterationsResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IterationResp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IterationCallBacksHandlerServer).IterationsResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/experiment.ml_data_collector.IterationCallBacksHandler/IterationsResults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IterationCallBacksHandlerServer).IterationsResults(ctx, req.(*IterationResp))
	}
	return interceptor(ctx, in, info, handler)
}

// IterationCallBacksHandler_ServiceDesc is the grpc.ServiceDesc for IterationCallBacksHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IterationCallBacksHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "experiment.ml_data_collector.IterationCallBacksHandler",
	HandlerType: (*IterationCallBacksHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IterationsResults",
			Handler:    _IterationCallBacksHandler_IterationsResults_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ml_data_collector_interface.proto",
}
